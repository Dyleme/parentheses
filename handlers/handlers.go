package handlers

import (
	"errors"
	"fmt"
	"net/http"
	"parentheses/parentheses"
	"strconv"
)

var (
	errNotPositiveArgument  = errors.New("argument isn't positive")
	errMethodNotAllowed     = errors.New("method isn't allowed")
	errParameterNotProvided = errors.New("parameter isn't provided")
	errNotConvertableToInt  = errors.New("can't convert to int")
)

// GeneratorHandler returns body with the bracket sequence
// generated by Generate function.
type GeneratorHandler struct {
	gen Generator
}

// New is constructor for GeneratorHandler.
func New(gen Generator) *GeneratorHandler {
	return &GeneratorHandler{gen: gen}
}

// Generator is interface to generate string.
type Generator interface {
	generate(length int) string
}

// Generation is implementation of Generator which generate random sequence of brackets.
type Generation struct{}

// DefaultGenerate generate random sequence of brackets.
func (g *Generation) generate(length int) string {
	return parentheses.GenerateBrackets(length)
}

// ServeHTTP handles only GET method
// Writes sequence of brackets in body or error if it occurs.
func (g *GeneratorHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	length, err := validateRequest(r)

	if errors.Is(err, errMethodNotAllowed) { //nolint:gocritic // if-else is easier to understand
		http.Error(w, err.Error(), http.StatusMethodNotAllowed)
	} else if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	} else {
		temp := g.gen.generate(length)

		w.Write([]byte(temp)) //nolint:errcheck // error can't appear.
	}
}

// function validateRequest checks if the method and parameter is correct.
// If the parameter "n" exists and if it is greater than 0.
// If error occur it returns (0, error), else it returns (value of parameter "n", nil).
func validateRequest(r *http.Request) (int, error) {
	if r.Method != http.MethodGet && r.Method != http.MethodHead {
		return 0, fmt.Errorf("%w: %s", errMethodNotAllowed, r.Method)
	}

	key, exist := r.URL.Query()["n"]

	if !exist {
		return 0, fmt.Errorf("%w: %s", errParameterNotProvided, "n")
	}

	length, err := strconv.Atoi(key[0])

	if err != nil {
		return 0, fmt.Errorf("%w: %q", errNotConvertableToInt, key[0])
	}

	if length < 1 {
		return 0, fmt.Errorf("%w: %v", errNotPositiveArgument, length)
	}

	return length, nil
}
